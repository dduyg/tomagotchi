<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scroll-Based Saturation with IntersectionObserver</title>
<style>
body {
    height: 200vh; /* make page scrollable */
    margin: 0;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: start;
}

.box {
    width: 200px;
    height: 200px;
    margin: 100px 0;
    background-image: url('https://via.placeholder.com/200');
    background-size: cover;
    border-radius: 10px;
    transition: filter 0.3s ease-out;
    text-align: center;
    line-height: 200px;
    font-weight: bold;
    color: white;
    font-size: 24px;
    filter: saturate(0%); /* default start */
}
</style>
</head>
<body>

<div class="box" data-start-saturate="50">Box 1</div>
<div class="box" data-start-saturate="25">Box 2</div>
<div class="box" data-start-saturate="0">Box 3</div>

<script>
// Function to calculate saturation based on intersection ratio
function setSaturation(entry) {
    const box = entry.target;
    const startSaturate = parseFloat(box.dataset.startSaturate);
    const endSaturate = 100;

    // Map intersection ratio (0-1) to 0% -> 32% of scroll (like keyframes)
    let ratio = entry.intersectionRatio / 0.32;
    ratio = Math.min(Math.max(ratio, 0), 1); // clamp between 0 and 1

    const saturation = startSaturate + (endSaturate - startSaturate) * ratio;
    box.style.filter = `saturate(${saturation}%)`;
}

// IntersectionObserver options
const options = {
    root: null,           // viewport
    rootMargin: '0px',
    threshold: Array.from({length: 101}, (_, i) => i/100) // 0,0.01,...1
};

// Create observer
const observer = new IntersectionObserver((entries) => {
    entries.forEach(setSaturation);
}, options);

// Observe all boxes
document.querySelectorAll('.box').forEach(box => observer.observe(box));
</script>

</body>
</html>
